# 基本运算符

运算符是一个用来检查、变改、结合值的特殊符号或者短语。例如，加号这个运算符(+)，就像在`let i = 1 + 2`中，让两个数相加。在`if enteredDoorCode && passedRetinaScan`中，逻辑与运算符(&&)，结合两个布尔值。

Swift支持大多数标准C运算符，并且提供了几个功能用来消除普遍的代码错误。赋值符号(=) 不会返回值，以防止在等于运算符(==)时被误用。当使用大于或小于存储它们的类型的允许值范围的数字时，算数运算符(+,-,*,/,%等等)检测和不允许值溢出，来避免异常结果。可以选择使用Swift的溢出运算符来计算溢出行为，详情参考溢出运算符。

Swift也提供C中不存在的运算符，比如`a..<b`和`a...b`，是表示值的范围的一种简写。

这一章讲Swift中普通的运算符。高级运算符在Swift的高级运算符中讲，其中还会讲如何定义你自定义的运算符，在自定义类中实现标准运算。

#####术语

运算符分一元、二元和三元：

* 一元运算符用在单个目标上（比如`-a`）。一元前缀运算符会在其目标(比如`!b`)之前出现，一元后缀运算符会在其目标(如`c!`)之后出现。
* 二元运算符用在两个目标上(比如`2+3`)并且出现在两个目标的中间。
* 三元运算符用在三个目标上，和C一样，Swift也只有一个三元运算符，三元条件运算符(`a ? b : c`)。

运算符作用于操作数。在`1 + 2`这个例子中，`+`是二元运算符，它作用于1和2两个操作数。

#####赋值运算符

赋值运算符(`a = b`) ，把`b`的值初始化或者更新给`a`：
```
let b = 10
var a = 5
a = b
// a 现在是 10
``` 
赋值符号的右边是一个有多个值的元组，它们的元素能立即被分解成多个常量或者变量：
```
let (x,y) = (1,2)
// x = 1 , y = 2
```
与C和Objective-C中的赋值符号不一样，Swift中的赋值符号本身不返回值。下面的语句是无效的：
```
if x = y {
    // 这是无效的， 因为 x = y 不返回值。
}
```
这个特性避可以防止在实际使用等于运算符(==)时，意外使用赋值运算符(=)。`if x = y`这种写法是无效的，Swift能避免这类错误出现在代码中。

##### 算数运算符

对所有数字类型，Swift支持四中标准的算数运算符：

* 加(+)
* 减(-)
* 乘(*)
* 除(/)

```
1 + 2 		// 等于3
5 - 3 		// 等于2
2 * 3 		// 等于6
10.0 / 2.5 // 等于4.0
```
与C和Objective-C中的算数运算符不一样，Swift算数运算符默认不允许值溢出。可以通过使用Swift的溢出运算符(比如 a &+ b)来选择启用溢出行为。参考溢出运算符。

加号运算符支持字符串相加来连接字符串：
```
"hello, " + "world" // 等于"hello, world"
```

######取余运算符

取余运算符(a % b) 计算出b的倍数后，还剩一个数，那就返回剩的数（叫做余数）。

注意
在其它语言中，取余运算符(%)又叫做取模运算符。但是，Swift对负数的行为，严格来说是余数而不是取模运算。

这里说了取余运算符是如何工作的。要计算 9 % 4 , 首先计算出会有几个4：
本例中能得到9中有2个4,然后它余下了1.

在Swift中，表示如下：
```
9 % 4 // 等于1
```
要确定a % b 的等于多少，% 运算符计算一下等式并返回余数作为其输出：
a = (b * some multiplier) + remainder
这里 some multiplier 是乘以 b 能得到 a 的最大的数。

将 9 和 4 插入到这个方程中得到：
9 = (4 * 2) + 1
当计算负数的余数是，这个方法也是一样的：
```
-9 % 4 // 等于 -1
```
将 -9 和 4 插入到这个方程中：
-9 = (4 * -2) + -1
得到余数是 -1
b 的负数值是被忽略的。这就以为着 a % b 和 a % -b 总是能得到相同的答案。

######一元负号运算符

在数字值前面使用一个`-`来切换值，被称为一元负号运算符。
```
let three = 3
let minusThree = -three      // minusThree 等于 -3
let plusThree = -minusThree  // plusThree 等于 3， or --three
```
一元负号运算符(-)直接放在值前面来运算它， 不要加任何空格。

######一元正号运算符

一元正号运算符(+)只返回其运算的值，不会有任何改变：
```
let minusSix = -6
let alsoMinusSix = +minusSix // alsoMinusSix 等于 -6
```
虽然一元正号运算符不会做任何操作，在使用一元负号来表示一个负数时，可以使用它来为代码中的正数提供对称性。

##### 组合赋值运算符

和C一样，Swift提供组合赋值运算符，组合赋值号(=)和其他的运算符。下面是一个相加的组合赋值运算符(+=)：
```
var a = 1
a += 2
// a 现在等于 3
```
表达式 a += 2 是 a = a + a 的缩写。 加号和等号有效地组合成一个同时执行这两个任务的运算符。

注意
组合赋值运算符不会返回值。例如，不能写`let b = a += 2`

Swift标准库提供了一个组合赋值运算符的完整列表，参考Swift标准库。

##### 比较运算符

Swift支持所有标准C的比较运算符：

* 等于(a == b)
* 不等于(a != b)
* 大于(a > b)
* 小于(a < b)
* 大于等于(a >= b)
* 小于等于(a <= b)

注意
Swift还提供了两个恒等式运算符(`===` 和 `!==`)，用于测试两个对象引用是否应用同一对象实例。了解更多信息，参考类和结构体。

每一个比较运算符都会返回一个布尔值，以表示该语句是否为真：
```
1 == 1 // 真， 因为1确实等于1
2 != 1 // 真， 因为2不等于1
2 > 1	 // 真
1 < 2 // 真
1 >= 1 // 真
2 <= 1 // 假
```
比较运算符经常在条件语句中使用，例如`if`语句：
```
let name = "world"
if name == "world" {
  print("hello, world")
} else {
  print("I'm sorry \(name), but I don't recognize you")
}
```
关于`if`语句的更多信息，参考控制流程。

可以比较具有相同数值的元组，只要元组的每一个值能被比较。例如：整型和字符串型能被比较，意味着(Int, String)类型的元组能被比较。相反，布尔型不能比较，意味着包含布尔型值的元组不能被比较。

元组的比较是从左到右，一次比较一个值，直到发现两个值不相等。这两个值被比较，其结果决定了两个元组比较的结果。如果全部元素都相等，那么元组就相等。例如：
```
(1, "zebra") < (2, "apple")	// 真， 因为1小于2； "zebra"和"apple"不用比较
(3, "apple") < (3, "bird") // 真， 3等于3， "apple" 小于 "bird"
(4, "dog") == (4, "dog") // 真
```
上述例子中，从第一行可以看出*从左向右*比较这种动作。因为1小于2，(1, "zebra")就小于(2, "apple")，而不管元组中的其他值。无论"zebra"是否小于"apple"，因为比较结果已经被元组的第一个元素决定了。然而，当元组的第一个元素相同，那就比较它们第二个元组——这就是第二行和第三行所展示的。

注意
Swift标准库包括元组比较运算符，用在小于7个元组的元组。去比较7个及以上的元素的元组，必须自己实现比较运算符。

#####三元条件运算符

三元条件运算符是一个特殊的运算符，有三个部分，它的形式是 *问题 ？ 答案1 : 答案2*。它是基于问题是真还是假来评估两个表达式之一的简写。如果问题是真，它返回答案1的值；否则，返回答案2的值。

三元条件运算符是以下代码的简写：
```
if question {
    answer1
} else {
    answer2
}
```
例如：计算一个table的行高。如果这行有header，就应该在原本的行高上加上50个points，没有的话就加上20的points：
```
let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
```
上面的例子是下面这个代码的简写：
```
let contentHgeht = 40
let hasHeader = true
let rowHeight: Int
if hasHeader {
    rowHeight = contentHeight + 50
} else {
    rowHeight = contentHeight + 20
}
```
第一个例子用了三元条件运算符，一行代码就能正确的设置行高，比第二个例子简洁。

三元条件运算符提供了一个简洁、高效的写法，用于两个表达式中选一个的情况。但是，使用三元条件运算符要小心。它的简明会让代码难易阅读。避免将三元条件运算符的多个实例组合成一个复合语句。

#####空聚合运算符

空聚合运算符(a ?? b) 解包可选a，如果它包含值；或者返回一个默认值b，如果a是空。这个表达式a总是可选类型。表达式b必须匹配a的类型。

空聚合运算符是下面代码的简写：
```
a != nil ? a! : b
```
上述代码使用三元条件运算符和强制解包(a!)来获取a的值，但如果a是空，那就返回b。空聚合运算符提供更优雅的方式来把这个检查和解包条件封装得简写和可读。

注意
如果a的值是非空的，那么b的值不会评估。这被称为短路评估。

下面的例子使用了空聚合运算符来选择默认颜色还是自定义颜色的名字：
```
let defaultColorName = "red"
var userDefinedColorName: String?
var colorNameToUse = userDefinedColorName ?? defaultColorName
```
useDefinedColorName 变量定义了一个可选字符串，默认值是空。因为 useDefinedColorName 是个可选类型，能使用空聚合运算符来考虑它的值。在上述例子中，运算符用于确定名为colorNameToUse的字符串类型变量的初始值。因为useDefinedColorName是空，表达式 userDefinedColorName ？？ defaultColorName 返回 defaultColorName的值，就是也 "red"。

如果赋值一个非空值到 useDefinedColorName 并且再次执行空聚合运算符来检查，这个userDefinedColorName 的解包值会替代默认值：
```
userDefinedColorName = "green"
colorNameToUse = userDefinedColorName ?? defaultColorName
```

##### 区间运算符

Swift中有几个范围运算符是表达一个值范围的简写。

######闭区间运算符

闭区间运算符(a...b)定义了一个从 a 到 b的区间， 并且包括值a和b。a值必须小于b值。

当想要使用所有范围内的值时，闭区间运算符很有用，比如这个`for-in`循环：
```
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
```
更多信息，参考控制流程。

######半开区间运算符

半开区间运算符(a..<b)定义了一个从 a 到 b 的区间，但是不包括b。说它是半开的，因为它包括第一个值，但是不包括最后一个值。作为半开区间运算符，a值必须小于b值。如果a等于b，这个范围结果将是空的。

当使用从零开始的列表（比如数组）时，半开区间特别有用，其中对列表的长度计算很有用：
```
let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count {
    print("Person \(i + 1) is called \(names[i])")
}
```
注意，数组包含四个元素，但是`0..<count`只算到3（数组中最后一个元素的下标），因为它是半开区间。更多关于数组的信息，参考数组。

######单面区间

闭区间运算符有这样一种可能，只有一个方向的范围。例如，一个包含数组中全部元素的范围，从下标2开始，到这个数组的结束。在这种情况下，可以从范围运算的一侧省略值。这种情况被称为单面区间，因为这个运算符只有一个方向值。例如：
```
for name in names[2...] {
    print(name)
}

for name in names[...2]{
    print(name)
}
```
半开区间运算符也有这种操作。就像在两边包含一个值一样，最终值不属于区间。例如：
```
for name in names[..<2] {
    print(name)
}
```
单面区间可以使用到其他地方，不仅仅是下标。不能忽略第一个值，使用单面区间来迭代，因为它不清楚该从哪开始迭代。可以迭代省略其最终值的区间；但是，因为范围能无限继续下去，确保为循环添加明确的结束条件。还可以检查单面区间是否包含特定之，如下面的代码所示。
```
let range = ...5
range.contains(7)  // 假
range.contains(4)  // 真
range.contains(-1) // 真
```

#####逻辑运算符

逻辑运算符修改或者合并布尔逻辑值`true`或`false`。Swift支持下列三种基于C语言的标注逻辑运算符：

* 逻辑非 (!a)
* 逻辑与 (a && b)
* 逻辑或 (a || b)

######逻辑非运算符

逻辑非运算符(!a)会反转布尔值，从`true`变成`false`，从`false`变成`true`。

逻辑非运算符是个前缀运算符，并且在其操作的值前面立即出现，没有任何空白。它可以理解成"不是a"，例子如下：
```
let allowedEntry = false
if !allowedEntry {
    print("ACCESS DENIED")
}
// 打印 "ACCESS DENIED"
```
`if !allowedEntry`这个短语，可以理解成"如果不允许输入"。后续仅在"不允许输入"为真时执行；也就是说，如果`allowedEntry`为`false`。

正如这个例子，仔细选择布尔常量和变量名可以帮助保持代码的可读性和简洁性，同时避免双重否定或混淆逻辑语句。

######逻辑与运算符

逻辑与运算符(a && b)创建一个逻辑表达式，如果表达式为真，那么里面的值必须全是真。

如果有值为假，那么表达式就为假。事实上，如果第一个值为假，第二个之甚至都不会判断，因为它不可能使整体表达式为真。这被称为短路判断。

下面例子考虑两个布尔值并且只有两个值都为true时才允许访问：
```
let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode && passedRetinaSacn {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
```

######逻辑或运算符

逻辑或运算符(a || b) 是一个由两个相邻的字符组成的中缀运算符。用它去创建逻辑表达式，这两个值只有一个为真，则整体表达式就为真。

就像上面的逻辑与运算符，逻辑或也有短路判断。如果逻辑或左边的表达式为真，那就为真，右边不去判断，因为它不会改变整体表达式的结果。

在下面这个例子中，第一个值(hasDoorKey)为假，但是第二个值(knowsOverridePassword)为真。因为其中一个值为真，所有整体表达式也判断为真，access被允许：
```
let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
```

######组合逻辑表达式

可以把多个逻辑表达式组合起来创建一个长复合逻辑表达式：
```
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
```
本例用多个`&&`和`||`运算符来创建一个长复合逻辑表达式。然而，`&&`和`||`运算符依然只能操作两个值，所以这可以看做三个小表达式的集合。可以这么理解：

如果我们输入正确的门密码并通过视网膜扫描，或者如果我们有一个有效的门钥匙，或者我们知道紧急覆盖密码，那么允许访问。

根据`enterDoorCode`，`passedRetinaScan`和`hasDoorKey`的值，前两个子表达式为假，然而，紧急覆盖密码是已知的，因此整体复合表达式的计算结果依然为真。

注意
Swift逻辑运算符&&和||是左结合，意思是多个逻辑运算符组合成的表达式从左边的第一个子表达式开始判断。

######明确的括号
在不严格需要的情况下，括号有时是有用的，可以让复杂的表达意图更容易理解。在上面的例子中，在复合表达式的第一部分周围添加括号是有用的，以使其意图明确：
```
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
```

括号表明，前两个值被认为是整个逻辑中单独可能状态的一部分。 复合表达式的输出不会改变，但读者的整体意图更为清晰。 可读性总是优于简洁; 使用括号，是意图清晰。


